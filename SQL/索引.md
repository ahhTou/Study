# 什么是 索引

- 官方定义：一种帮助MySQL提供查询效率的数据结构
- 索引数据结构

# 索引的优点

1. 大大加快数据查询速度

# 索引的缺点

1. 维护索引需要耗费数据库资源
2. 索引需要占用磁盘空间
3. 当对表的数据进行增删改的时候，因为要维护索引，速度会受影响

# 索引分类

- a. 主键索引
  - 设定为主键厚，数据库会自动简历索引，`innoDB`为聚簇索引，主键索引索引列值不能为空
- b. 单值索引 （单列索引、普通索引）
  - 即一个索引只包含单个例，一个表可以有多个单例索引
- c. 唯一索引
  - 索引的值必须唯一，但允许有空值，但是只能存在一个
- d. 复合索引
  - 即一个索引，包含多个实例
- e. Full Text 全文索引 （MySQL 5.7 版本之前 只能用于 `MyISAM` 引擎）
  - 全文所以能吨类型为 FULL TEXT ,在定义索引的列上支持值的全文查找，允许在这些索引中插入重复值和空值，全文索引可以用在CHAR、VARCHAR、TEXT 类型上创建，MYSQL 只有 `MyISAM` 存储引擎支持全文索引

## 主键索引

**自动创建**

```sql
-- 主键索引，无需创建
-- 主键索引是建表的时候自动创建的
create table t_user(id VARCHAR(20) primary key, name VARCHAR(20));

-- 查看索引
show index from t_user;
```



![image-20210818170145408](.\img\1)

## 普通索引

```sql
-- 普通索引创建的两种方式

-- 1. 建表之后创建
create index name_index on t_user(name);

-- 2. 建表时创建
-- create table 表名(字段, 字段, ..., key(字段名), key(字段名)...)
create table t_user1(id varchar(20) primary key, name varchar(20), key(name));
```

## 唯一索引

```sql
-- 1. 建表时创建
create table t_user2(id varchar(20) primary key, name varchar(20), unique(name));

-- 2. 建表后创建
create unique index name_index on t_user2(name)
```



## 复合索引*



```SQL
-- 1. 建表时创建
create table t_user3(id varchar(20) primary key, name varchar(20), age int,  key(name, age));

-- 2. 建表后创建
create index name_age_index on t_user3(name, age);
```



索引名一致

![](.\img\2.png)



### 最左前缀原则*

1. 最左前缀原则：查询的字段必须复合是复合索引为前缀，如上图查询的字段顺序必须为 `name, age, + 其他字段`

 2. MySQL 引擎在查询为了更好的利用索引，在查询过程中会动态调整查询字段的顺序，以便利用索引。 

    `name, bir, age` 会被调整为 `name, age, bir`, 所以也符合 `最左前缀原则`

    但是像 `name, bir` 就无法查询， 因为不同时包含`name` 和 `age`

# B+Tree

基于叶的管理 ： 一页默认  16KB

![](.\img\3.png)

从上一节中的B-Tee结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点(即一个页)能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键佶大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

B-Tree 和 B+Tree最大的区别是：B-Tree每个节点必须都存储数据，而B+Tree只需要叶子节点存储数据

B+Tree相比于B-Tree 有几点不同

1. 非叶子节点 只能存储键值信息。
2. 所有叶子节点之间都有一个链指针。
3. 数据记录都存放在叶子节点中。

- `InnoDB`存储引擎中页的大小为16KB, 一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型页一般为4 或 8 个直接，也就是一共页（B+Tree中的一共节点），中大概存储16KB/(8B+8B)=1K个键值。（因为是估值，为方便计算，这里的K取值为10^3）。也就是说深度为3 的B+Tree索引可以维护10^3 * 10^3 * 10 ^ 3 = 10亿条记录
- 实际情况中，每个节点不可能填充满，因此数据库中，B+Tree的高度一般都在2-4层，MySQL的`InnoDB`存储引擎在设计时是将根节点，**常驻内存**，也就是说，查找某一键值对的行记录时，最多只需要读取1~3次磁盘I/O操作

# 聚簇索引和非聚簇索引

- `聚簇索引`:将数据存储与素引放到了一块，索引结构的叶子节点保存了行数据

- `非聚簇索引`:将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置

注意：**在`InnoDB`在聚簇索引之上创建的索引称之为辅助索引。非聚蔟索引都是辅助索引，像复合索引、前缀索引、唯一索引。辅助索引叶子节点存储的不再是行的物理位置。而是主键值，辅助索引访问数据总是需要二次查找**。**

![](D:\code\d_mysql\img\4.png)

1. `InnoDB`

- `lnnoDB`使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id= 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。
- 若对Name列进行条件搜索，则需要两个步骤:第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。(重点在于通过其他键需要建立辅助索引)
- **聚簇索引默认是主键**，如果表中没有定义主键，`InnoDB`会选择一个唯一旦非空的索引代替。如果没有这样的索引，`InnoDB`会隐式定义一个主键(类似
  oracle中的Row ID)来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。

2. `MyISAM`

`MyISAM`使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键,辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于**索引树是独立的，通过辅助键检索无需访问主键的索引树**。

![](.\img\5.png)

# 使用聚簇索引的优势

问题:每次使用辅助索引检索都要经过两次B+树查找，看上去聚簇索引的效率明显要低于非聚簇索引，这不是多此一举吗?聚簇索引的优势在哪?

1. 由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加蛛到了Buffer中(级存器)，再次访问对，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。
2. 辅助索引的十子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要分裂变化﹔或者是我们需要查找的该数据，在上一次1o读写的缓存中没有，需要发生一次新的`I/O`操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。

# 聚簇索引需要注意什么?

。当使用主键为聚簇索引时，主键最好不要使用`uuid`，因为`uuid`的值太过离散，不适合排序且可能土线新增加记录的`uuid`，会插入在索引树中间的位置，导致索引树调整复杂度变大，消耗更多的时间和资源。
。建议使用`int`类型的自增，方便排序并且默认会在索引树的末尾增加主键值，对索引树的结杓影响最小。而且，主键值占用的有储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间,也会影响到`I/O`操作读取到的数据量。

# 为什么主键通常建议使用自增id

聚簇索引的数据的物理存放顺序与索引顺序是一致的，即:只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

# 什么情况下无法利用索引呢?

1. 查询语句中使用`like`关键字
   在查询语句中使用`like`关键字进行查询时，如果匹配字符串的第一个字符为`%`，索引不会被使用。如果不是在`%`第一个位置，索引就会被使用。
2. 查询语句中使用多列索引
   多列索引是在表的多个字段上创建一个索引，只有查询条件中使用了这些字段中的第一个字段，索引才会被使用。
3. 询语句中使用`or`关键字
   查询语句只有`or`关键字时，如果`or`前后的两个条件的列/都是索引，那么查询中将使用索引。如果`or`前后有一个条件的列不是索引，那么查询中将不使用索引。
