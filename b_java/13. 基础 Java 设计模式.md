# 七大原则



## 单一职责

单一职责原则注意事项和细节

1. 降低类的复杂度一个类只负青一项职责。
2. 提高类的可读性，可维护性
3. 降低变更引起的风险一
4. 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违
    反单一职责原则;只有类中方法数量足够少，可以在方法级别保持单一职责原则

## 接口隔离

## 依赖倒转

> 父类不要直接依赖子类，而依赖一个接口类

依赖倒转原则(Dependence lnversion Principle)是指:

1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象
2. 抽象不应该依赖细节，细节应该依赖抽象
3. 依赖倒转(倒置)的中心思想是面向接口编程
4. 依赖倒转原则是基于这样的设计理念:相对于细节的多变性，抽象的东西要稳定的
    多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类
5. 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的
    任务交给他们的实现类去完成

## 里氏替换

> 尽量不要重写父类的方法，如果要重写就提取两个类的共同父类



oo中的继承性的思考和说明

1. 继承包含这样一层含义:父类中凡是已经实现好的方法，实际上是在设定规范和契
    约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。
2. 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵
    入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障
3. 问题提出:在编程中，如何正确的使用继承?=>里氏替换原则

基本介绍

基本介绍

1. 里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院的以为姓里
    的女士提出的。
2. 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序
    P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地万必须能透明地使用其子类的对象。
3. 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
4. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可
    以通过聚合,组合,依赖来解决问题。.

## 开闭原则

> 对扩展是开放的 ，使用方尽量不要修改

基本介绍

1. 开闭原则(Open Closed Principle）是编程中最基础、最重要的设计原则
2. 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。
3. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已
    有的代码来实现变化。
4. 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。



## 迪米特法则

基本介绍

1. 一个对象应该对其他对象保持最少的了解
2. 类与类关系越密切，耦合度越大
3. 迪米特法则(Demeter Principle)又叫**最少知道原则**，即一个类对自己依赖的类知道的
    越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息
4. 迪米特法则还有个更简单的定义:只与直接的朋友通信
5. 直接的朋友:每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系
    我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

## 合成复用原则

基本介绍

- 原则是尽量使用合版/聚合的方式，而不是使用继承





# 单例

## 饿汉式 - 静态变量

优缺点说明:

1. 优点:这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。
2. 缺点:在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始
    至终从未使用过这个实例，则会造成内存的浪费
3. 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载
    时就实例化，在单例模式中大多数都是调用getlnstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果
4. 结论:这种单例模式可用，可能造成内存浪费

```java
/**
 * 饿汉式 - 静态变量
 */
class Singleton {


    // 1. 构造器私有化，外部不能new
    private Singleton() {
    }

    // 2. 本列内部创建对象实例
    private static final Singleton instance = new Singleton();

    // 3. 提供一个共有的静态方法 ，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }

}
```

## 饿汉式 - 静态代码块

优缺点说明:

1. 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块
    中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。
2. 结论:这种单例模式可用，但是可能造成内存浪费

```java
/**
 * 饿汉式 - 静态变量块
 */
class Singleton2 {


    // 1. 构造器私有化，外部能new
    private Singleton2() {
    }

    // 2. 本列内部创建对象实例
    private static final Singleton2 instance;

    static {
        // 在静态状态块中， 创建单例对象
        instance = new Singleton2();
    }


    // 3. 提供一个共有的静态方法 ，返回实例对象
    public static Singleton2 getInstance() {
        return instance;
    }

}
```



## 懒汉式 - 线程不安全

> 线程不安全

优缺点说明:一

1. 起到了Lazy Loading的效果，但是只能在单线程下使用。
2. 如果在多线程下，一个线程进入了if (singleton m= null)判断语句块，还未来得及
    往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式
3. 结论:在实际开发中，不要使用这种方式.



```java
/**
 * 懒汉式
 * 1. 线程 不安全
 */
public class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    // 提供一个静态的公用方法 当使用到该方法时才去创建instance
    public static Singleton getInstance() {
        if (instance == null) return new Singleton();
        return instance;
    }

}
```

## 懒汉式 - 线程安全

> 效率低下

优缺点说明:

1. 解决了线程不安全问题
2. 效率太低了，每个线程在想获得类的实例时候，执行getlnstance()方法都要进行
    尚步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低
3. 结论:在实际开发中，不推荐使用这种方式

```java
/**
 * 懒汉式 - 线程安全
 * 1. 效率低下
 */
public class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    // 提供一个静态的公用方法 当使用到该方法时才去创建instance
    public static synchronized Singleton getInstance() {
        if (instance == null) return new Singleton();
        return instance;
    }

}
```



## 懒汉式 - 同步代码块

> 无用功，线程不安全

优缺点说明:

1. 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块
2. 但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一
    致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例
3. 结论:在实际开发中，不能使用这种方式

```java
/**
 * 懒汉式 - 同步代码块
 */
public class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    // 提供一个静态的公用方法 当使用到该方法时才去创建instance
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                instance = new Singleton();
            }
        }
        return instance;
    }

}
```



## 双重检查

> 双重检查(DoubleCheck)

优缺点说明:

1. Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两
    次if (singleton =- null桧香，这样就可以保证线程安全了。
2. 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，
    直接return实例化对象，也避免的反复进行方法同步.
3. 线程安全;延迟加载;效率较高
4. 结论:在实际开发中，推荐使用这种单例设计模式



```java
/**
 * 双重检查 - double check
 */
public class Singleton {
    // 立马更新到主存
    private static volatile Singleton instance;

    private Singleton() {
    }

    // 提供一个静态的公用方法 当使用到该方法时才去创建instance
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) instance = new Singleton();
            }
        }
        return instance;
    }

}
```



## 静态内部类

优缺点说明:

1. 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
2. 静态内部类方式在singleton类被装载时并不会立即实例化，而是在需要实例化
    时，调用getlnstance方法，牙会装载SingletonInstance类，从而完成singleton的实例化。
3. 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
4. 优点:避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
5. 结论:推荐使用.



## 枚举

优缺点说明:

1. 这借助JDK1.5中添加的杓举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
2. 这种方式是Effective Java作者Josh Bloch提倡的方式
3. 结论:推荐使用

```java
/**
 * 枚举 - 推荐使用
 */
public enum Singleton {
    INSTANCE;

    public void sayOK() {
        System.out.println("OK");
    }

    public static void main(String[] args) {
        Singleton instance = Singleton.INSTANCE;
        instance.sayOK();
    }
}
```



# 工厂模式



1. 工厂模式的意义
    将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
2. 三种工厂模式(简单工厂模式、工厂方法模式、抽象工厂模式
3. 设计模式的依赖抽象原则
   

- 创建对象实例时，不要直接new类,而是把这个new类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。
- 不要让类继承具体类，而是继承抽象类或者是实现interface(接口)>
- 不要覆盖基类中已经实现的方法。



## 简单工厂模式

基本介绍

1. 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一
    个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式
2. 简单工厂模式:定义了一个创建对象的类，由这个类来**封装实例化对象的行为(代码)**
3. 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会
    使用到工厂模式.

## 工厂方法模式

定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。



## 抽象工厂模式

基本介绍

1. 抽象工厂模式:定义了一个interface用于创建相关或有依赖关系的对象簇，而无需
    指明具体的类
2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象
4. 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。程序员可以
    根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。



# 原型模式

基本介绍

1. 原型模式(Prototype模式)是指:用原型实例指定创建对象的种类，并且通过拷
    贝这些原型，创建新的对象
2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
3. 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()
4. 形象的理解:孙大圣拔出猴毛，变出其它孙大圣



## 浅拷贝

```java
@Override
protected ProSheep clone() {
    ProSheep sheep = null;
    try {
        sheep = (ProSheep) super.clone();
    } catch (CloneNotSupportedException e) {
        System.out.println(e.getMessage());
    }
    return sheep;
}
```

## 深拷贝 - clone

```java
// 深拷贝 - 方式1 使用clone 方法
@Override
protected DeepProtoType clone() throws CloneNotSupportedException {

    DeepProtoType deep = null;

    // 这里完成对基本数据类型和String的克隆
    deep = (DeepProtoType) super.clone();

    // 对引用类型的属性，进行单独的处理
    deep.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();

    return deep;
}
```

## 深拷贝 - 反序列化

```java
// 深拷贝 - 方式2 通过对象的序列化实现（推荐）
public DeepProtoType deepClone() {
    // 创建流对象
    ByteArrayOutputStream bo = null;
    ByteArrayInputStream bi = null;
    ObjectOutputStream oo = null;
    ObjectInputStream oi = null;

    try{
        bo = new ByteArrayOutputStream();
        oo = new ObjectOutputStream(bo);
        oo.writeObject(this); // 当前这个对象以对象流的方式输出


        // 反序列化
        bi = new ByteArrayInputStream(bo.toByteArray());
        oi = new ObjectInputStream(bi);

        return (DeepProtoType) oi.readObject();


    } catch (Exception e) {
        System.out.println(e.getMessage());
    } finally {
        try {
            if (bo != null) bo.close();
            if (bi != null) bi.close();
            if (oo != null) oo.close();
            if (oi != null) oi.close();
        }catch (Exception e2) {
            System.out.println(e2.getMessage());
        }
    }

    return null;

}
```



# 建造者模式

1. 建造者模式(Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别)，使这个抽象过程的不同实现芳法可以构造出不同表现て属性）的对象。
2. 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象
    的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。

建造者模式的四个角色

- Product(产品角色):一个具体的产品对象。
- Builder（抽象建造者):创建一个Product对象的各个部件指定的接口。
- ConcreteBuilder（具体建造者):实现接口，构建和装配各个部件。
- Director(指挥者):构建一个使用Builder接口的对象。它主要是用于创建一个
    复杂的对象。它主要有两个作用，一是:隔离了客户与对象的生产过程，二是:负责控制产品对象的生产过程。



建造者模式的注意事项和细节

1. 客户端(使用程序)不必知道产品内部织成的细节，凝产品本身有产品的创建过程解
    耦，使得相同的创建过程可以创建不同的产品对象
2. 每一个具体建诰者都相对独立，而与其他的具体建造者无关，因此可以很方便地替
    换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象
3. 可以事加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法
    中，使得创建过程更加清晰，也更方便使用程序来控制创建过程
4. 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，
    系统扩展方便，符合“开闭原则”

# 适配器模式

基本介绍

1. 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表
    示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)
2. 适配器模式属于结构型模式
3. 主要分为三类:类适配器模式、对象适配器模式、接口适配器模式

工作原理

1. 适配器模式:将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容——
2. 从用户的角度看不到被适配者，是解耦的
3. 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法
4. 用户收到反馈结果，感觉只是和目标接口交互，如图





## 类适配器

类适配器模式介绍
基本介绍: Adapter类，通过继承src类，实现 dst类接口，完成src->dst的适配。

类适配器模式应用实例

1. 应用实例说明
    以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter，220v交流电相当于src (即被适配者)，我们的目dst(即目标)是5V直流电
2. 思路分析图解
3. 代码实现



类适配器模式注意事项和细节

1. Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要
    求dst必须是接口，有一定局限性;
    中
2. src类的方法在Adapter中都会暴露出来，也增加了使用的成本。
3. 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵
    活性增强了。



## 对象适配器

对象适配器模式介绪

1. 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而
    是持有src类的实例，以解决兼容性的问题。即:持有src类，实现 dst类接口，完成src->dst的适配
2. 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。3)对象适配器模式是适配器模式常用的一种



## 接口适配器

接口适配器模式介绍

1. 一些书籍称为:适配器模式(Default Adapter Pattern)或缺省适配器模式。
2. 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接
    口中每个方法提供一个默认实现（空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求
3. 适用于一个接口不想使用其所有的方法的情况。



# 桥接模式



# 装饰者模式



# 组合模式

基本介绍

1. 组合模式(Composite Pattern)，又部分整体模式，它创建了对象组的树形结
    构，将对象组合成树状结构以表示“整体-部分”的层次关系。一
2. 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
3. 这种类型的设计模式属て结构型模式。
4. 组合模式使得用户对单个对象和组合对象的访问具有一致性，即:组合能让客
    户以一致的方式处理个别对象以及组合对象

- Component: 这是组合中对象声明接口,在适当情况下，实现所有类共有的接口默认行为,用于访问和管理amprnant 子部件，Component可以是抽象类或者接口
- Leaf: 组合中叶子节点, 叶子节点没有子节点
- Composite： 非叶子节点，用于储存子部件，在Component接口实现子部件的相关操作，比如增加，删除。。。





# 外观模式

基本介绍

1. 外观模式(Facade)，也叫“过程模式:外观模式为子系统中的一组接口提供
    一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
2. 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端
    只需跟这个接口发生调用，而无需关心这个子系统的内部细节



原理类图的说明

- 外观类（Facade）为掉哦那个端提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而调用端的请求的代理给适当的系统对象
- 调用者（Client）外观接口的调用者
- 子系统的集合 指模块或者子系统，处理Facade对象指派的任务，他是功能的提供者



 

# 享元模式

- FlayWeight是抽象的享元角色。他是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现
- ConcreteFlayWeight 是 具体的享元角色，是具体的产品类，实现抽i想角色定义的相关义务
- UnSharedCOncreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂
- FlyWeightFactory 享元工厂类，用于构建一个池对象（集合）同时提供从池中获取对象的方法





内部状态和外部状态
比如围棋、五子棋、跳棋，它们都有大量的棋子对象╱围棋和五子棋只有里白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态;而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态

1. 享元模式提出了两个要求:细粒度和共享对象这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分:内部状态和外部状态
2. 内部状态指对象共享出来的信息，存储在享元对象内部旦不会随环境的改变而改变
3. 外部次态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。
4. 举个例子:围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对
    象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题



# √ 代理模式

代理模式的基本介绍

1. 代理模式:为一个对象提供一个替身，以控制对这个对象的访问。即通过代理
    对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的中功能操作,即扩展目标对象的功能。
2. 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象
3. 代理模式有不同的形式，主要有三种静态代理、动态代理(JDK代理、接口代
    理)和Cglib代理(可以在内存动态的创建对象，而不需要实现接口。



## √ 静态代理



## √ 动态代理



## √ Cglib





# 模板方法

基本介绍

1. 模板方法模式( Template Method Pattern)，又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
2. 简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子
    类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤
3. 这种类型的设计模式属于行为型模式。

模板方法模式的钩子方法

1. 在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。
2. 还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配`料，请使用钩子方法对前面的模板方法进行改造



# 命令模式

命令模式基本介绍基本介绍

1. 命令模式(Command Pattern):在软件设计中，我们经常需要
    向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，
    我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计
2. 命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。
3. 在命名模式中，会将一个请求封装为一个对象，以便使用不同参
    数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作4)通俗易懂的理解:将军发布命令，士兵去执行。其中有几个角色:将军（命令发布者)、士兵（命令的具体执行者)、命令(连接将军和士兵)。lnvoker是调用者（将军)，Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象



角色

- Invoker 调用者角色
- Command 命令角色，需要自行的所有命令都在这里，可以是接口或是抽象类
- Receiver 接收者，知道如何实施和自行一个请求相关的操作
- ConcreteCommand 将一个接收者对象 与 一个动作 绑定，调用接收者相应的操作，实现Execute



# ？访问者模式

> 通过 os 将 visitor 传入 各个element，然后各个element在把自己（this）传入到visitor中

访问者模式基本介绍

1. 访问者模式(Visitor Pattern)，封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
2. 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题
3. 访问者模式的基本工作原理是:在被访问的类里面加一个对外提供接待访问者
    的接口
4. 访问者模式主要应用场景是:需要对一个对象结构中的对象进行很多不同操作
    (这些操作彼此没有关联)，同时需要避免让这些操作"污染"这些对象的类，可以选用访问者模式解决

角色

1. Visitor 是抽象访问者，为改对象结构中的ConcreteElement的每一个类声明一个visit操作
2. ConcreteVisitor: 是一个具体的访问者，实现每个有Visitor声明的操作，是每个操作实现的部分。
3. ObjectStructure 能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问元素
4. Element 定义一个accept方法，可以接受一个访问者对象
5. ConcreteElement 为具体的元素，实现了accept方法



访问者模式的注意事项和细节
优点

1. 访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高
2. 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据
    结构相对稳定的系统
    缺点
    1. 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部级节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困
    2. 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素
    3. 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问
        者模式就是比较合适的.

# 迭代器模式

迭代器模式基本介绍
基本介绍

1. 迭代器模式（ lterator Pattern）是常用的设计模式，属于行为型模式
2. 如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类，
    或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。
3. 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，
    不需要知道集合对象的底层表示，即:不暴露其内部的结构。

> 迭代器模式的注意事项和细节人优点

1)提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以
遍历对象了。
2)隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚
合的具体组成。
3)提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任
原则)。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。
4)当要展示一组相似对象，或者遍历一组相同对象时使用，适合使用迭代器模式

> 缺点

每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类



# 观察者模式



# 中介者模式

基本介绍

1. 中企者模式(Mediator Pattern),[用一个中介对象来封装一系列的对象交互。
    中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
2. 中介者模式属于行为型模式，使代码易于维护
3. 比如MVC模式，c (Controller控制器）是M (Model模型）和v (View视图）的中
    介者，在前后端交互时起到了中间人的作用

中介者模式的注意事项和细节

1. 多个类相互耦合，会形成网状结构,使用中介者模式将网状结构分离为星型结构，进行解耦

2. 减少类间依赖，降低了耦合，符合迪米特原则

3. 中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响4)）如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意

    

# 备忘录模式

基本介绍

1. 备忘录模式(Memento Pattern)在不破坏封装性的前提下，捕获一个对象的内
    部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态
2. 可以这里理解备忘录模式:现实生活中的备忘录是用来记录某些要去做的事情
    或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作
3. 备忘录模式属于行为型模式



角色

|对原理类图的说明-即
(备忘录模式的角色及职责)

1. originator :对象(需要保存状态的对象)
2. Memento :备忘录对象,负责保存好记录，即Originator内部人
3. Caretaker : 负责保存多个备忘录对象，使用集合管理，提高效率
4. 说明：如果希望保存多个originator对象的不同时间的状态，也可以，只需要HashMap<String, 集合>