```
DefaultSecurityManager sm = new DefaultSecurityManager();
CustomerMd5Realm realm = new CustomerMd5Realm();

// 设置凭证器
HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();
// 使用的什么算法
matcher.setHashAlgorithmName("md5");
// 散列次数
matcher.setHashIterations(1024);
realm.setCredentialsMatcher(matcher);
sm.setRealm(realm);

SecurityUtils.setSecurityManager(sm);

Subject subject = SecurityUtils.getSubject();

UsernamePasswordToken token = new UsernamePasswordToken("tou", "123");

try {
    subject.login(token);
    System.out.println("登陆成功");
} catch (AuthenticationException e) {
    e.printStackTrace();
    System.out.println("用户名错误");
}
```

# Shiro

## 关键对象

- Subject 主题： 访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体;
- Principal 身份信息：是主体(subject)进行身份认证的标识，标识必须具有唯一性，如用户名、手机号、邮箱地址等一个主体可以有多个身份，但是必须有一个主身份(Primary Principal)。
- credential 凭证信息：是只有主体自己知道的安全信息，如密码、证书等。



## 配置文件

.ini文件，没有命名格式，可以放入任意文件夹中

ini 配置文件 用来学习shiro书写我们系统中的相关权限

实际项目中用不到，只是为了帮助学习shiro时候减轻压力



## 第一个Demo

```java
// 1. 创建安全管理器对象
DefaultSecurityManager securityManager = new DefaultSecurityManager();

// 2. 给安全管理器设置realms
securityManager.setRealm(new IniRealm("classpath:shiro.ini"));

// 3. SecurityUtils 全局安全的工具类, 并给其设置安全管理器
SecurityUtils.setSecurityManager(securityManager);

// 4. 关键对象 Subject 主题
Subject subject = SecurityUtils.getSubject();

// 5. 创建令牌
UsernamePasswordToken token = new UsernamePasswordToken("tou", "1123");

// 6. 通过令牌登录认证
try {
    System.out.println("认证状态 -> " + subject.isAuthenticated());
    subject.login(token);
    System.out.println("认证状态 -> " + subject.isAuthenticated());
} catch (UnknownAccountException e) {
    System.out.println("认证失败 -> 用户名不存在");
    e.printStackTrace();
} catch (IncorrectCredentialsException e) {
    System.out.println("认证失败 -> 密码错误");
    e.printStackTrace();
}
```

流程：

1. 最终执行用户名比较SimpleAccountRealm
    doGetAuthenticationInfo在这个方法中完成用户名校验

2. 最终密码校验是在AuthenticatingRealm中
    assertCredentialsMatch

总结
AuthenticatingRealm   认证realm    doGetAuthenticationInfo
AuthorizingRealm         授权realm    doGetAuthorizationInfo

## 认证

使用自定义realm

```java
public class CustomerRealm extends AuthorizingRealm {
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        return null;
    }

    /*
     * 认证
     * */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        // 在token中获取用户名
        String principal = (String) token.getPrincipal();
        System.out.println(principal);
        if ("tou".equals(principal)) {
            // 参数1 返回数据库中确定用户名，2 返回数据库中的正确密码 3 当前realm的名字；
            SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo("tou", "123", this.getName());
            return simpleAuthenticationInfo;
        }
        return null;
    }
}
```

## Md5 + Salt



使用Md5

```java
DefaultSecurityManager sm = new DefaultSecurityManager();
CustomerMd5Realm realm = new CustomerMd5Realm();

// 设置凭证器 ，如果没有进行加密可以不配置凭证器
HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();
// 使用的什么算法
matcher.setHashAlgorithmName("md5");
// 散列次数, 如果没有进行散列，不加
matcher.setHashIterations(1024);
realm.setCredentialsMatcher(matcher);
sm.setRealm(realm);

SecurityUtils.setSecurityManager(sm);

Subject subject = SecurityUtils.getSubject();

UsernamePasswordToken token = new UsernamePasswordToken("tou", "123");

try {
    subject.login(token);
    System.out.println("登陆成功");
} catch (AuthenticationException e) {
    e.printStackTrace();
    System.out.println("用户名错误");
}
```

```java
@Override
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
    String principal = (String) token.getPrincipal();
    if ("tou".equals(principal)) {
        String password = "8dda8e350b9167ff463701743bd2c5c5";
        String salt = "X0**at";

        // 1. 数据库用户名 2 数据库md5 + salt 之后的密码 3： 注册的盐 4. 类名
        return new SimpleAuthenticationInfo(principal, password,
                ByteSource.Util.bytes(salt),
                this.getName());
    }
    return null;
}
```



## 授权

```java
public class CustomerMd5Realm extends AuthorizingRealm {
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principal) {
        System.out.println("======== 授权 ========");
        String primaryPrincipal = (String) principal.getPrimaryPrincipal();
        System.out.println("身份信息：" + primaryPrincipal);

        // 根据身份信息 用户名 获取当前用户的角色信息， 以及权限信息
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();

        // 将数据库中查询的角色信息赋值给权限对象
        info.addRole("admin");
        info.addRole("users");

        // 将数据库中查询的权限信息赋值给权限对象
        info.addStringPermission("user:*:01");

        return info;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        String principal = (String) token.getPrincipal();
        if ("tou".equals(principal)) {
            String password = "8dda8e350b9167ff463701743bd2c5c5";
            String salt = "X0**at";

            // 1. 数据库用户名 2 数据库md5 + salt 之后的密码 3： 注册的盐 4. 类名
            return new SimpleAuthenticationInfo(principal, password,
                    ByteSource.Util.bytes(salt),
                    this.getName());
        }
        return null;
    }
}
```

判断权限

```java
// 认证用户 进行授权
if (subject.isAuthenticated()) {
    // 1. 基于角色的权限控制
    System.out.println("admin - " + subject.hasRole("admin"));
    System.out.println("users - " + subject.hasRole("users"));
    System.out.println("super - " + subject.hasRole("super"));

    // 2. 基于多角色的权限控制
    System.out.println("super & users -" + subject.hasAllRoles(Arrays.asList("admin", "super")));

    // 3. 是否含有其中一个角色
    boolean[] booleans = subject.hasRoles(Arrays.asList("admin", "super"));
    for (boolean aBoolean : booleans) {
        System.out.println(aBoolean);
    }

    // 4. 基于权限字符串的访问控制 资源标识符:操作:资源类型
    System.out.println("资源访问权限 - " + subject.isPermitted("user:*:01"));

    // 5. 分别具有那些权限
    boolean[] permitted = subject.isPermitted("user:update:01", "order:*:01");
    for (boolean b : permitted) {
        System.out.println(b);
    }

    // 6. 同时具有那些权限
    boolean permittedAll = subject.isPermittedAll("user:update:01", "order:*:01");
    System.out.println(permittedAll);
}
```

# Boot

```java
/*
 * 用来整合
 * */
@Configuration
public class ShiroConf {

    // 1. 创建shiroFilter
    @Bean
    public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager sm) {
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();

        // 给filter 设置安全管理器
        bean.setSecurityManager(sm);

        // 配置系统的受限资源
        // 配置系统公共资源
        Map<String, String> map = new HashMap<>();
        map.put("/hello", "authc"); // 请求这个资源需要认证和授权

        // 设置默认认证界面路径 如果没有通过授权将跳转到该界面
        bean.setLoginUrl("/login");

        // 将map设置给bean
        bean.setFilterChainDefinitionMap(map);

        return bean;
    }

    // 2. 创建安全管理器
    @Bean
    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier("realm") Realm realm) {
        DefaultWebSecurityManager sm = new DefaultWebSecurityManager();

        // 给安全管理器设置Realm
        sm.setRealm(realm);

        return sm;
    }

    // 3. 创建自定义realm
    @Bean("realm")
    public Realm getRealm() {
        return new CustomerRealm();
    }

}
```

# 过滤器

默认过滤器

常见

| 配置缩写          | 对应过滤器                     | 功能                                                         |
| ----------------- | ------------------------------ | ------------------------------------------------------------ |
| anon              | AnonymousFilter                | 指定url可以默认访问                                          |
| authc             | FormAuthenticationFilter       | 指定url需要form表单登录，默认会从请求中获取<br/>username . password , rememberMe 等参数并尝试登录，如果登录不了就会跳转到loginurl配置的路径。我们也可以用这个过滤器做默认的登录逻辑,但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。 |
| authcBasic        | BasicHttpAuthenticationFilter  | 指定url需要basic登录                                         |
| logout            | LogoutFilter                   | 登出过滤器,配置指定url就可以实现退出功能，非常方便           |
| noSessionCreation | NoSessioncreationFilter        | 禁止创建会话                                                 |
| perms             | PermissionsAuthorizationFilter | 需要指定权限才能访问                                         |
| port              | PortFilter                     | 需要指定端口才能访问                                         |
| rest              | HttpMethodPermissionFilter     | 将http请求方法转化成相应的动词来构造一个权限字符串，这个感赏 |
| roles             | RolesAuthorizationFilter       | 需要指定角色才能访问                                         |
| ssl               | SslFilter                      | 需要https请求才能访问                                        |
| user              | UserFilter                     | 需要已登录或“记住我”的用户才能访问                           |



# 实例

## 登录

```java
@PostMapping("/login")
public String login(String username, String password) {

    // 获取主题对象 (安全管理器已经被注入)
    Subject subject = SecurityUtils.getSubject();
    try {
        subject.login(new UsernamePasswordToken(username, password));
    } catch (UnsupportedOperationException e) {
        System.out.println("用户名错误");
        return "用户名错误";
    } catch (IncorrectCredentialsException e) {
        System.out.println("密码错误");
        return "密码错误";
    }


    return "登陆成功";
}
```

## 退出

```java
@GetMapping("/logout")
public String logout() {
    SecurityUtils.getSubject().logout();
    return "退出成功";
}
```



# 注解

常规授权

```java
@GetMapping("/isAdmin")
public String isAdmin() {
    Subject subject = SecurityUtils.getSubject();
    if (subject.hasRole("admins")) {
        return "No Admin Role";
    }
    return "You Are Admin";
}
```

注解

```java
@GetMapping("/isAdmin")
@RequiresRoles("admin")
@RequiresPermissions("user:update:01")
or
@RequiresRoles(value = {"admin"})
@RequiresRoles({"admin"})
public String isAdmin() {
    return "You Are Admin";
}
```

# Cache

## Encache

在自定义realm中配置

```java
@Bean("realm")
public Realm getRealm(@Qualifier("touRealm") CustomerRealm customerRealm) {
    HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();
    matcher.setHashAlgorithmName("MD5");
    matcher.setHashIterations(1024);
    // 修改凭证校验匹配器
    customerRealm.setCredentialsMatcher(matcher);

    // 开启缓存管理
    customerRealm.setCacheManager(new EhCacheManager());
    customerRealm.setCachingEnabled(true);
    customerRealm.setAuthorizationCacheName("authorizationCache");
    customerRealm.setAuthenticationCacheName("authenticationCache");
    customerRealm.setAuthenticationCachingEnabled(true); // 授权缓存
    customerRealm.setAuthorizationCachingEnabled(true); // 认证缓存

    return customerRealm;
}
```

## Redis

自定义Salt 序列化

在认证中修改

```java
...
...
if (!ObjectUtils.isEmpty(user)) {
    return new SimpleAuthenticationInfo(
            user.getUsername(), // 用户名
            user.getPassword(), //
            new MyByteSource(user.getSalt()), 
            this.getName());
}
...
...
```

Salt实现序列化

```java
public class MyByteSource extends SimpleByteSource implements Serializable {

    public MyByteSource(String string) {
        super(string);
    }
    
}
```

配置 RedisCache

```java
@Component
@Data
@Accessors(chain = true)
@SuppressWarnings("unchecked")
public class RedisCache<K, V> implements Cache<K, V> {

    private String cacheName;

    @Autowired
    @Qualifier("redisTemplate4shiro")
    RedisTemplate<String, Object> redisTemplate;

    @Override
    public V get(K k) throws CacheException {
        return (V) redisTemplate.opsForHash().get(this.cacheName, k);
    }

    @Override
    public V put(K k, V v) throws CacheException {
        System.out.println("Shiro-Redis-Put");
        redisTemplate.opsForHash().put(this.cacheName, k, v);
        return v;
    }

    @Override
    public V remove(K k) throws CacheException {
        return (V) redisTemplate.opsForHash().delete(this.cacheName, k.toString());
    }

    @Override
    public void clear() throws CacheException {
        redisTemplate.opsForHash().delete(this.cacheName);
    }

    @Override
    public int size() {
        return getRedisTemplate().opsForHash().size(this.cacheName).intValue();
    }

    @Override
    public Set<K> keys() {
        return (Set<K>) redisTemplate.opsForHash().keys(this.cacheName);
    }

    @Override
    public Collection<V> values() {
        return (Collection<V>) redisTemplate.opsForHash().values(this.cacheName);
    }
}
```

缓存管理 使用上面的RedisCache

```java
@Component("shiroRedisCache")
public class RedisCacheManager implements CacheManager {

    @Resource
    RedisCache<?, ?> redisCache;

    @Override
    @SuppressWarnings("unchecked")
    public <K, V> Cache<K, V> getCache(String cacheName) throws CacheException {
        return (Cache<K, V>) redisCache.setCacheName(cacheName);
    }
}

```

并在自定义realm中设置

```java
// 3. 创建自定义realm
@Bean("realm")
public Realm getRealm(@Qualifier("touRealm") CustomerRealm customerRealm, @Qualifier("shiroRedisCacheManager") RedisCacheManager redisCacheManager) {
    HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();
    matcher.setHashAlgorithmName("MD5");
    matcher.setHashIterations(1024);
    // 修改凭证校验匹配器
    customerRealm.setCredentialsMatcher(matcher);

    // 开启缓存管理
    customerRealm.setCacheManager(redisCacheManager);
    customerRealm.setCachingEnabled(true);
    customerRealm.setAuthorizationCacheName("authorizationCache");
    customerRealm.setAuthenticationCacheName("authenticationCache");
    customerRealm.setAuthenticationCachingEnabled(true); // 授权缓存
    customerRealm.setAuthorizationCachingEnabled(true); // 认证缓存

    return customerRealm;
}
```