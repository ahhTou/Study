# 内存结构

## 1. 程序计数器

Program Counter Register 程序计数器 （寄存器）

- 作用 记住下一条jvm指定的执行地址
- 特点：
  1. 线程私有
  2. 不会内存溢出



## 2. 虚拟机栈

### 定义

Java Virtual Machine Stacks （Java 虚拟机栈）

- 每个线程运行时所需要的内存， 成为虚拟机栈
- 每个栈有多个栈帧（Frame）组成，对应着每次方法所占用的内存
- 每个线程只能有一个活动栈帧（栈顶），对应着当前执行的那个方法

栈帧：每个方法运行时需要的内存 （参数、局部变量、返回地址）

1. 垃圾回收是否设计涉及栈内存

   不涉及，每次方法执行完毕，会自己弹出栈，会自己回收。不需要垃圾回收。而垃圾回收是回收堆内存的。

2. 栈内存分配越打越好吗

   栈内存分配的越大，线程数就越小

3. 方法内的局部变量

   - 如果方法内局部变量没有逃离方法的作用范围，那他就是线程安全的
   - 如果是局部变量引用了对象，并逃离了方法的作用范围，那么需要考虑线程安全问题

### 栈内存溢出

* 栈帧过多导致栈内存溢出
* 栈帧过大导致栈内存溢出





## 3. 本方法栈

为那些不能由java实现的方法，提供内存空间



## 4. Heap 堆

### 定义

- 通过new关键字，创建对象都会使用堆内存

特点

- 他是线程共享的，堆中的对象都需要考虑线程安全的问题
- 有垃圾回收机制



### 堆内存溢出

OutOfMemoryError : Java heap space



## 5. 方法区

### 定义 

所有java虚拟机线程共享的一块区域

存储了和类的结构有关的信息

逻辑上是堆的一部分（不同的jvm厂商可能不同）

### 组成

![](.\img\2.png)

### 运行时常量池

- 常量池，就是一张表，虚拟机指令根据这张常聊表找到要执行的类名、方法名、参数类型、字面量等信息
- 运行时常量池， 常量池是*.class 文件中的，当该类被加载，他的常量池信息就会被放入运行时常量池，并把里面的符号地址变为真实地址。



### StringTable

StringTable ["a", "ba", "ab"] hashtable 结构 ，不能扩容

```java
String s1 = "a"; // 懒惰的
String s2 = "b";
String s3 = "ab"; // 在 串池 StringTable中

// 变量相加 相当于 new StringBuilder().append(s1).append(s2).toString();
// toString() : StringBuilder -> new String()
String s4 = s1 + s2; // 在堆中

String s5 = "a" + "b"; // javac 在编译期间的优化，已经确定为ab

System.out.println(s3 == s4); // false;

System.out.println(s3 == s5); // true
```

StringTable 特性

- 常量池中的字符串仅是符号，第一次用到时，才变成对象
- 利用串池的机智，避免重复创建字符串对象
- 字符串变量拼接的原理是StringBuilder （1.8）
- 字符串变量的拼接原理是编译器优化
- 可以使用intern方法，主动将串词还没有的字符串放入串词。
  - 1.8 将这个字符串对象尝试放入串词中，如果有不放，没有则放。将串词中的返回
  - 1.6  将这个字符串对象尝试放入串词中，如果有不放，没有则复制一份这个对象，将副本放入串词（副本和原对象不同），会把串词中对象的返回

```java
// ["a", "b", "ab"]
String s = new String("a") + new String("b");

String s2 = s.intern();

System.out.println(s2 == "ab"); // true

=============================================

// ["a", "b"]
String s = new String("a") + new String("b");

// String s2 = s.intern();

System.out.println(s == "ab"); // false
```

### StringTable 垃圾回收

如果给新的字符串分配堆内存时，堆内存空间不够，就会触发垃圾回收，将之前的没有被引用的字符串对象回收掉。

### StringTable 性能调优

StringTable的底层是hash表，hash表的桶的个数比较多，hash碰撞的几率就比较大，存放的速度就会变快，桶的个数越少，hash碰撞的几率就比较大，存放的速度就越慢。

StringTableSize桶的个数越多，存放的速度就越快

- 调整桶个数 -XX:StringTableSize=1009
- 考虑将字符串对象是否入池：使用intern，可以去除重复的字符串内存占用。





## 直接内存

### 定义

不属于Java虚拟机，是操作系统的内存

- 常见NIO操作时，用于数据缓存区
- 分配回收成本较高，但读写性能高
- 不受JVM 内存回收管理

###  分配和回收原理

内部使用unsafe类进行直接内存的管理回收

```java
// 分配内存
long l = unsafe.allocateMemory(1000L);

// 管理内存
unsafe.freeMemory(l);
```

- 使用unsafe对象完成字节内存的分配回收，并且回收需要主动调用frreMemory
- ByteBuffer的实现类内部，使用了Cleaner （虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放字节内存





